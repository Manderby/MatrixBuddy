
// //////////////////////////////////
// English
//
NA_LOC_LANG("eng");

NA_LOC(MatrixBuddyApplicationDescription, "Compute vector algebra thingies. Matrix and Vector, you know. That kind of stuff");

NA_LOC(MATHelpVMulS,          "Multiplies a vector by a scalar. Fill in a and s to compute b.");
NA_LOC(MATHelpVDivS,          "Divides a vector by a scalar. Fill in a and s to compute b.");
NA_LOC(MATHelpVMulCompV,      "Multiplies the components of a vector by the components of another vector. Fill in a and b to compute c.");
NA_LOC(MATHelpVDivCompV,      "Divides the components of a vector by the components of another vector. Fill in a and b to compute c.");

NA_LOC(MATHelpNegV,           "Negates a vector. Fill in v to compute the negated vector. You may also fill in the other side.");
NA_LOC(MATHelpVAddV,          "Adds vector b to vector a. Fill in b to compute c. Fill in c to solve for b.");
NA_LOC(MATHelpVSubV,          "Subtracts vector b from vector a. Fill in b to compute c. Fill in c to solve for b.");
NA_LOC(MATHelpVDotV,          "Computes the dot product of a and b. Fill in a and b to compute the product.");
NA_LOC(MATHelpVCrossV,        "Computes the cross product of a and b. Only available for 3D. Fill in a and b to compute the product.");
NA_LOC(MATHelpLengthV,        "Computes the euclidian length of a vector. Fill in v to compute the length.");

NA_LOC(MATHelpNormalizeV,     "Normalizes the vector. Fill in v to compute the normalized vector.");
NA_LOC(MATHelpOrthogonalizeV, "Makes a orthogonal to b. Fill in a and b to compute the orthogonalized vector.");
NA_LOC(MATHelpMirrorV,        "Mirrors a along surface with normal n. Fill in a and n to compute the mirrored vector.");

NA_LOC(MATHelpMMulS,          "Multiplies a matrix by a scalar. Fill in A and s to compute B.");
NA_LOC(MATHelpMDivS,          "Divides a matrix by a scalar. Fill in A and s to compute B.");
NA_LOC(MATHelpMMulCompV,      "Multiplies the columns of a matrix by the components of a vector. Fill in A and v to compute B.");
NA_LOC(MATHelpMDivCompV,      "Divides the columns of a matrix by the components of a vector. Fill in A and v to compute B.");
NA_LOC(MATHelpMMulCompM,      "Multiplies the components of a matrix by the components of anoter matrix. Fill in A and B to compute C.");
NA_LOC(MATHelpMDivCompM,      "Divides the components of a matrix by the components of anoter matrix. Fill in A and B to compute C.");

NA_LOC(MATHelpNegM,           "Negates a matrix. Fill in A to compute the negated matrix. You may also fill in the other side.");
NA_LOC(MATHelpMAddM,          "Adds matrix B to matrix A. Fill in B to compute C. Fill in C to solve for B.");
NA_LOC(MATHelpMSubM,          "Subtract matrix B from matrix A. Fill in B to compute C. Fill in C to solve for B.");
NA_LOC(MATHelpMMulV,          "Multiplication of a matrix with a vector. Fill in x to compute b. Fill in b to solve for x.");
NA_LOC(MATHelpMMulM,          "Multiplication of a matrix with a matrix. Fill in B to compute C. Fill in C to solve for B.");

NA_LOC(MATHelpDiagS,          "Create a diagonal matrix out of a scalar. Fill in s to compute A.");
NA_LOC(MATHelpDiagV,          "Create a diagonal matrix out of a vector. Fill in v to compute A.");
NA_LOC(MATHelpTransposeM,     "Transposes a matrix. Fill in A to compute the transposed matrix.");
NA_LOC(MATHelpInvertM,        "Inverts a matrix. Fill in A to compute the inverse.");

NA_LOC(MATErrorMatrixDeterminantZero,       "Can't invert");
NA_LOC(MATErrorMatrixDeterminantAlmostZero, "Determinant almost zero");
NA_LOC(MATErrorVectorComponentZero,         "Can't divide");
NA_LOC(MATErrorVectorComponentAlmostZero,   "Component almost zero");
NA_LOC(MATErrorMatrixComponentZero,         "Can't divide");
NA_LOC(MATErrorMatrixComponentAlmostZero,   "Component almost zero");
NA_LOC(MATErrorScalarZero,                  "Can't divide");
NA_LOC(MATErrorScalarAlmostZero,            "Almost zero");
NA_LOC(MATErrorVectorLengthZero,            "Length zero");
NA_LOC(MATErrorVectorLengthAlmostZero,      "Almost zero");
NA_LOC(MATErrorVectorsCollinear,            "Collinear");
NA_LOC(MATErrorVectorsAlmostCollinear,      "~ collinear");
NA_LOC(MATErrorVectorLengthUnequalOne,      "Not Normal");

